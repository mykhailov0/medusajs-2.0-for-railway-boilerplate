"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const liqpay_1 = __importDefault(require("../lib/liqpay"));
const medusa_1 = require("@medusajs/medusa");
const utils_1 = require("@medusajs/utils");
const liqpay_interfaces_1 = require("../lib/interfaces/liqpay.interfaces");
const noDivisionCurrencies = [
    "krw",
    "jpy",
    "vnd",
    "clp",
    "pyg",
    "xaf",
    "xof",
    "bif",
    "djf",
    "gnf",
    "kmf",
    "mga",
    "rwf",
    "xpf",
    "htg",
    "vuv",
    "xag",
    "xdr",
    "xau",
];
class LiqPayPaymentProcessor extends medusa_1.AbstractPaymentProcessor {
    constructor(container, options) {
        super(container, options);
        if (!options.public_key) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.INVALID_ARGUMENT, "The LiqPay provider requires the public_key option");
        }
        if (!options.private_key) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.INVALID_ARGUMENT, "The LiqPay provider requires the private_key option");
        }
        this.configuration = options;
        this.liqpay = new liqpay_1.default(this.configuration.public_key, this.configuration.private_key, {
            disable_retries: options.disable_retries,
        });
        this.debug = Boolean(options.debug);
        // Container is just an object - https://docs.medusajs.com/development/fundamentals/dependency-injection#in-classes
        this.cartService = container.cartService;
        if (this.cartService.retrieveWithTotals === undefined) {
            throw new utils_1.MedusaError(utils_1.MedusaError.Types.UNEXPECTED_STATE, "Your Medusa installation contains an outdated cartService implementation. Update your Medusa installation.");
        }
    }
    convertToDecimal(amount, region) {
        var _a;
        const divisor = noDivisionCurrencies.includes((_a = region === null || region === void 0 ? void 0 : region.currency_code) === null || _a === void 0 ? void 0 : _a.toLowerCase())
            ? 1
            : 100;
        return Math.floor(amount) / divisor;
    }
    async authorizePayment(paymentSessionData, context) {
        if (this.debug) {
            console.info("LP_P_Debug: AuthorizePayment", JSON.stringify(paymentSessionData, null, 2));
        }
        try {
            const { orderId, cartId } = paymentSessionData;
            const data = await this.liqpay.transaction.get({
                id: cartId,
            });
            const cart = await this.cartService.retrieveWithTotals(cartId);
            if (this.debug) {
                console.info("LP_P_Debug: AuthorizePayment: Verification", JSON.stringify({ liqpay: data, status: data.status, cart }, null, 2));
            }
            if (data.status === liqpay_interfaces_1.LiqPayStatusEnum.error ||
                data.status === liqpay_interfaces_1.LiqPayStatusEnum.failure ||
                data.status === liqpay_interfaces_1.LiqPayStatusEnum.try_again || data.err_code) {
                return {
                    status: medusa_1.PaymentSessionStatus.ERROR,
                    data: {
                        ...paymentSessionData,
                        orderId: orderId,
                        cartId: cart.id,
                        liqpayData: data
                    },
                };
            }
            if (data.status) {
                switch (data.status) {
                    case 'success':
                    case 'subscribed': {
                        const total = this.convertToDecimal(cart.total, cart.region);
                        // Calculate fee with minimum of 0.01
                        const fee = Math.ceil((total * 0.015) * 100) / 100;
                        // Base amount validation
                        const amountValid = total === data.amount;
                        // Amount with proper fee validation
                        const amountWithFeeValid = Math.abs(data.amount - (total + fee)) < 0.0099;
                        const currencyValid = cart.region.currency_code.toLowerCase() === data.currency.toLowerCase();
                        if (this.debug) {
                            console.info("LP_P_Debug: AuthorizePayment: Verification of Amount and Currency", JSON.stringify({
                                currencyValid,
                                amountValid,
                                amountWithFeeValid,
                                liqPayAmount: data.amount,
                                cartAmount: total,
                                cartAmountWithFee: total + fee,
                                fee: fee,
                                liqPayCurrency: data.currency,
                                cartCurrency: cart.region.currency_code
                            }, null, 2));
                        }
                        if ((amountValid || amountWithFeeValid) && currencyValid) {
                            // Successful transaction
                            return {
                                status: medusa_1.PaymentSessionStatus.AUTHORIZED,
                                data: {
                                    orderId: orderId,
                                    cartId: cartId,
                                    liqpayData: data
                                },
                            };
                        }
                        // Invalid amount or currency
                        // We refund the transaction
                        await this.refundPayment({
                            ...paymentSessionData,
                            orderId: orderId,
                            cartId: cartId,
                            liqpayData: data
                        }, cart.total);
                        // And return the failed status
                        return {
                            status: medusa_1.PaymentSessionStatus.ERROR,
                            data: {
                                ...paymentSessionData,
                                orderId: orderId,
                                cartId: cartId,
                                liqpayData: data
                            },
                        };
                    }
                    case 'error':
                    case 'failure':
                    case 'try_again':
                        return {
                            status: medusa_1.PaymentSessionStatus.ERROR,
                            data: {
                                ...paymentSessionData,
                                orderId: orderId,
                                cartId: cartId,
                                liqpayData: data
                            },
                        };
                    default:
                        return {
                            status: medusa_1.PaymentSessionStatus.PENDING,
                            data: paymentSessionData,
                        };
                }
            }
            else {
                return {
                    status: medusa_1.PaymentSessionStatus.PENDING,
                    data: paymentSessionData,
                };
            }
        }
        catch (error) {
            return this.buildError("Failed to authorize payment", error);
        }
    }
    async cancelPayment(paymentSessionData) {
        return paymentSessionData;
    }
    async capturePayment(paymentSessionData) {
        return paymentSessionData;
    }
    async deletePayment(paymentSessionData) {
        return paymentSessionData;
    }
    async getPaymentStatus(paymentSessionData) {
        if (this.debug) {
            console.info("LP_P_Debug: GetPaymentStatus", JSON.stringify(paymentSessionData, null, 2));
        }
        const { cartId } = paymentSessionData;
        if (!cartId) {
            return medusa_1.PaymentSessionStatus.PENDING;
        }
        try {
            const { status } = await this.liqpay.transaction.get({
                id: cartId,
            });
            switch (status) {
                case liqpay_interfaces_1.LiqPayStatusEnum.success:
                case liqpay_interfaces_1.LiqPayStatusEnum.subscribed:
                    return medusa_1.PaymentSessionStatus.AUTHORIZED;
                case liqpay_interfaces_1.LiqPayStatusEnum.unsubscribed:
                case liqpay_interfaces_1.LiqPayStatusEnum.reversed:
                    return medusa_1.PaymentSessionStatus.CANCELED;
                case liqpay_interfaces_1.LiqPayStatusEnum.error:
                case liqpay_interfaces_1.LiqPayStatusEnum.failure:
                case liqpay_interfaces_1.LiqPayStatusEnum.try_again:
                    return medusa_1.PaymentSessionStatus.ERROR;
                default:
                    return medusa_1.PaymentSessionStatus.PENDING;
            }
        }
        catch (error) {
            return medusa_1.PaymentSessionStatus.ERROR;
        }
    }
    async initiatePayment(context) {
        if (this.debug) {
            console.info("LP_P_Debug: InitiatePayment", JSON.stringify(context, null, 2));
        }
        return {
            session_data: {
                cartId: context.resource_id,
            },
        };
    }
    async refundPayment(paymentSessionData, refundAmount) {
        if (this.debug) {
            console.info("LP_P_Debug: RefundPayment", JSON.stringify({ paymentSessionData, refundAmount }, null, 2));
        }
        try {
            const { cartId } = paymentSessionData;
            const cart = await this.cartService.retrieveWithTotals(cartId);
            const translatedAmount = this.convertToDecimal(refundAmount, cart.region);
            if (this.debug) {
                console.info("LP_P_Debug: RefundPayment", JSON.stringify({ paymentSessionData, cart, translatedAmount }, null, 2));
            }
            const data = await this.liqpay.refund.create({
                id: cartId,
                amount: translatedAmount,
            });
            const { status } = data;
            if (status !== liqpay_interfaces_1.LiqPayStatusEnum.reversed) {
                return this.buildError("Failed to refund payment", {
                    detail: '',
                });
            }
            return {
                ...paymentSessionData,
                liqpayData: data,
            };
        }
        catch (error) {
            return this.buildError("Failed to refund payment", error);
        }
    }
    async retrievePayment(paymentSessionData) {
        if (this.debug) {
            console.info("LP_P_Debug: RetrievePayment", JSON.stringify(paymentSessionData, null, 2));
        }
        try {
            const { cartId } = paymentSessionData;
            const data = await this.liqpay.transaction.get({
                id: cartId,
            });
            if (data.status === liqpay_interfaces_1.LiqPayStatusEnum.error) {
                return this.buildError("Failed to retrieve payment", { detail: '' });
            }
            return {
                ...paymentSessionData,
                liqpayTxData: data,
            };
        }
        catch (error) {
            return this.buildError("Failed to retrieve payment", error);
        }
    }
    async updatePayment(context) {
        return this.initiatePayment(context);
    }
    async updatePaymentData(sessionId, data) {
        if (this.debug) {
            console.info("LP_P_Debug: UpdatePaymentData", JSON.stringify({ sessionId, data }, null, 2));
        }
        if (data.amount) {
            throw new utils_1.MedusaError(utils_1.MedusaErrorTypes.INVALID_DATA, "Cannot update amount from updatePaymentData");
        }
        return {
            session_data: {
                ...data, // We just return the data as is
            },
        };
    }
    buildError(message, e) {
        const errorMessage = "LiqPay Payment error: " + message;
        const code = e instanceof Error ? e.message : e.code;
        const detail = e instanceof Error ? e.stack : e.detail;
        return {
            error: errorMessage,
            code: code !== null && code !== void 0 ? code : "",
            detail: detail !== null && detail !== void 0 ? detail : "",
        };
    }
}
LiqPayPaymentProcessor.identifier = "liqpay";
exports.default = LiqPayPaymentProcessor;
