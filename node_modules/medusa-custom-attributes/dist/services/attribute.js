"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultAttributeRelations = void 0;
const medusa_1 = require("@medusajs/medusa");
const typeorm_1 = require("typeorm");
const medusa_core_utils_1 = require("medusa-core-utils");
exports.defaultAttributeRelations = ["values", "categories"];
class AttributeService extends medusa_1.TransactionBaseService {
    constructor({ attributeRepository, productCategoryRepository, }) {
        super(arguments[0]);
        this.attributeRepository_ = attributeRepository;
        this.productCategoryRepository_ = productCategoryRepository;
    }
    async create(data) {
        var _a, _b;
        const attributeRepo = this.activeManager_.withRepository(this.attributeRepository_);
        const categories = (_b = (_a = data === null || data === void 0 ? void 0 : data.categories) === null || _a === void 0 ? void 0 : _a.map((c) => ({ id: c }))) !== null && _b !== void 0 ? _b : [];
        const attribute = attributeRepo.create({
            ...data,
            categories,
        });
        const duplicate = await attributeRepo.findOne({
            where: { handle: attribute.handle },
        });
        if (duplicate) {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.CONFLICT, `"Attribute" with handle ${duplicate.handle} already exists`);
        }
        return await attributeRepo.save(attribute);
    }
    async list({ categories }, defaultConfig = {}) {
        const attributeRepo = this.activeManager_.withRepository(this.attributeRepository_);
        const where = defaultConfig.where || {};
        const config = {
            relations: exports.defaultAttributeRelations,
            order: {
                values: {
                    rank: "ASC",
                },
            },
            ...defaultConfig,
        };
        if (categories) {
            config.where = [
                {
                    ...where,
                    categories: {
                        handle: (0, typeorm_1.In)(categories),
                    },
                },
                {
                    ...where,
                    categories: {
                        id: (0, typeorm_1.IsNull)(),
                    },
                },
            ];
        }
        const attributes = await attributeRepo.find(config);
        return attributes;
    }
    async retrieve(id, config) {
        const attributeRepo = this.activeManager_.withRepository(this.attributeRepository_);
        const attribute = await attributeRepo.findOne({
            where: { id },
            ...config,
        });
        if (!attribute) {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, `"Attribute" with id ${id} was not found`);
        }
        return attribute;
    }
    async update(id, data) {
        const attributeRepo = this.activeManager_.withRepository(this.attributeRepository_);
        const attribute = await this.retrieve(id);
        if (!attribute) {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.NOT_FOUND, `"Attribute" with id ${id} was not found`);
        }
        Object.keys(data).forEach((update) => {
            if (update === "categories") {
                const categories = data[update].map((c) => ({ id: c }));
                // @ts-ignore
                attribute["categories"] = categories;
                return;
            }
            attribute[update] = data[update];
        });
        delete attribute.id;
        const createdAttribute = attributeRepo.create(attribute);
        const duplicate = await attributeRepo.findOne({
            where: { handle: createdAttribute.handle, id: (0, typeorm_1.Not)(id) },
        });
        if (duplicate) {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.CONFLICT, `"Attribute" with handle ${duplicate.handle} already exists`);
        }
        return await attributeRepo.save({ ...createdAttribute, id });
    }
    async delete(id) {
        const attributeRepo = this.activeManager_.withRepository(this.attributeRepository_);
        try {
            return await attributeRepo.delete(id);
        }
        catch (error) {
            throw new medusa_core_utils_1.MedusaError(medusa_core_utils_1.MedusaError.Types.DB_ERROR, `Failed to delete attribute with id: ${id}`);
        }
    }
}
exports.default = AttributeService;
